package br.ufba.matc89.provider;

import java.util.List;

import br.ufba.matc89.dao.GenericDAO;
import android.app.Activity;
import android.app.ActivityManager;
import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.UriMatcher;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQueryBuilder;
import android.net.Uri;
import android.os.Binder;
import android.os.Build;
import android.support.v7.appcompat.BuildConfig;
import android.text.TextUtils;
import android.util.Log;
import br.ufba.matc89.provider.SuperTreinoContract.Alimentos;

public class SuperTreinoProvider extends ContentProvider {
	// helper constants for use with the UriMatcher
	private static final int ALIMENTO_LIST = 1;
	private static final int ALIMENTO_ID = 2;
	private static final UriMatcher URI_MATCHER;
	
	private GenericDAO mDB = null;
	private final ThreadLocal<Boolean> mIsInBatchMode = new ThreadLocal<Boolean>();

	static {
		URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
		URI_MATCHER.addURI(SuperTreinoContract.AUTHORITY, "alimentos", ALIMENTO_LIST);
		URI_MATCHER.addURI(SuperTreinoContract.AUTHORITY, "alimentos/#", ALIMENTO_ID);
	}
	
	@Override
	public boolean onCreate() {
		mDB = new GenericDAO(getContext());
		return true;
	}

	@Override
	public String getType(Uri uri) {
		switch (URI_MATCHER.match(uri)) {
			case ALIMENTO_LIST:
				return Alimentos.CONTENT_TYPE;
			case ALIMENTO_ID:
				return Alimentos.CONTENT_ITEM_TYPE;
			default:
				throw new IllegalArgumentException("Unsupported URI: " + uri);
		}
	}

	@Override
	public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
		doAnalytics(uri, "query");

		SQLiteDatabase db = mDB.getReadableDatabase();
		SQLiteQueryBuilder builder = new SQLiteQueryBuilder();
		boolean useAuthorityUri = false;
		switch (URI_MATCHER.match(uri)) {
			case ALIMENTO_LIST:
				builder.setTables(DbSchema.TBL_ALIMENTOS);
		      	if (TextUtils.isEmpty(sortOrder)) {
		    	  	sortOrder = Alimentos.SORT_ORDER_DEFAULT;
		      	}
				break;
			case ALIMENTO_ID:
				builder.setTables(DbSchema.TBL_ALIMENTOS);
				// limit query to one row at most:
				builder.appendWhere(Alimentos._ID + " = "
						+ uri.getLastPathSegment());
				break;
			default:
				throw new IllegalArgumentException("Unsupported URI: " + uri);
		}
		Cursor cursor = builder.query(db, projection, selection, selectionArgs,
				null, null, sortOrder);
		// if we want to be notified of any changes:
		if(useAuthorityUri) {
		   cursor.setNotificationUri(getContext().getContentResolver(), SuperTreinoContract.CONTENT_URI);
	   	} else {
		   	cursor.setNotificationUri(getContext().getContentResolver(), uri);
	   	}
		return cursor;
	}

	@Override
	public Uri insert(Uri uri, ContentValues values) {
		doAnalytics(uri, "insert");
		if (URI_MATCHER.match(uri) != ALIMENTO_LIST) {
			throw new IllegalArgumentException(
					"Unsupported URI for insertion: " + uri);
		}
		SQLiteDatabase db = mDB.getWritableDatabase();
		if (URI_MATCHER.match(uri) == ALIMENTO_LIST) {
			long id = db.insert(DbSchema.TBL_ALIMENTOS, null, values);
			return getUriForId(id, uri);
		} else {
			// this insertWithOnConflict is a special case; CONFLICT_REPLACE
			// means that an existing entry which violates the UNIQUE constraint
			// on the item_id column gets deleted. That is this INSERT behaves
			// nearly like an UPDATE. Though the new row has a new primary key.
			// See how I mentioned this in the Contract class.
			//long id = db.insertWithOnConflict(DbSchema.TBL_PHOTOS, null, values, SQLiteDatabase.CONFLICT_REPLACE);
			//return getUriForId(id, uri);
			return null;
		}
	}
	
	private Uri getUriForId(long id, Uri uri) {
      if (id > 0) {
         Uri itemUri = ContentUris.withAppendedId(uri, id);
         if (!isInBatchMode()) {
            // notify all listeners of changes and return itemUri:
            getContext().
                  getContentResolver().
                        notifyChange(itemUri, null);
         }
         return itemUri;
      }
      // s.th. went wrong:
      throw new SQLException("Problem while inserting into uri: " + uri);
	}

	@Override
	public int update(Uri uri, ContentValues values, String selection,
			String[] selectionArgs) {
		doAnalytics(uri, "update");
		SQLiteDatabase db = mDB.getWritableDatabase();
		int updateCount = 0;
		switch (URI_MATCHER.match(uri)) {
			case ALIMENTO_LIST:
				updateCount = db.update(DbSchema.TBL_ALIMENTOS, values, selection,
						selectionArgs);
				break;
			case ALIMENTO_ID:
				String idStr = uri.getLastPathSegment();
				String where = Alimentos._ID + " = " + idStr;
				if (!TextUtils.isEmpty(selection)) {
					where += " AND " + selection;
				}
				updateCount = db.update(DbSchema.TBL_ALIMENTOS, values, where,
						selectionArgs);
				break;
			default:
				// no support for updating photos!
				throw new IllegalArgumentException("Unsupported URI: " + uri);
		}
		// notify all listeners of changes:
		if (updateCount > 0 && !isInBatchMode()) {
			getContext().getContentResolver().notifyChange(uri, null);
		}
		return updateCount;
	}
	
	@Override
	public int delete(Uri uri, String selection, String[] selectionArgs) {
		doAnalytics(uri, "delete");
		   
		SQLiteDatabase db = mDB.getWritableDatabase();
		int delCount = 0;
		switch (URI_MATCHER.match(uri)) {
		case ALIMENTO_LIST:
			delCount = db.delete(DbSchema.TBL_ALIMENTOS, selection, selectionArgs);
			break;
		case ALIMENTO_ID:
			String idStr = uri.getLastPathSegment();
			String where = Alimentos._ID + " = " + idStr;
			if (!TextUtils.isEmpty(selection)) {
				where += " AND " + selection;
			}
			delCount = db.delete(DbSchema.TBL_ALIMENTOS, where, selectionArgs);
			break;
		default:
			// no support for deleting photos or entities -
			// photos are deleted by a trigger when the item is deleted
			throw new IllegalArgumentException("Unsupported URI: " + uri);
		}
		// notify all listeners of changes:
		if (delCount > 0 && !isInBatchMode()) {
			getContext().getContentResolver().notifyChange(uri, null);
		}
		return delCount;
	}

	private boolean isInBatchMode() {
		return mIsInBatchMode.get() != null && mIsInBatchMode.get();
   	}

	/**
	 * I do not really use analytics, but if you export
	 * your content provider it makes sense to do so, to get
	 * a feeling for client usage. Especially if you want to
	 * _change_ something which might break existing clients,
	 * please check first if you can safely do so.
	 */
	private void doAnalytics(Uri uri, String event) {
	   if (BuildConfig.DEBUG) {
         Log.v("cpsample", event + " -> " + uri);
         Log.v("cpsample", "caller: " + detectCaller());
	   }
	}
	
   /** 
    * You can use this for Analytics. 
    * 
    * Be aware though: This might be costly if many apps 
    * are running.
    */
   private String detectCaller() {
      // found here:
      // https://groups.google.com/forum/#!topic/android-developers/0HsvyTYZldA
      int pid = Binder.getCallingPid();
      return getProcessNameFromPid(pid);
   }

   /**
    * Returns the name of the process the pid belongs to. Can be null if neither
    * an Activity nor a Service could be found.
    * @param givenPid
    * @return
    */
   private String getProcessNameFromPid(int givenPid) {
      ActivityManager am = (ActivityManager) getContext().getSystemService(
            Activity.ACTIVITY_SERVICE);
      List<ActivityManager.RunningAppProcessInfo> lstAppInfo = am
            .getRunningAppProcesses();
      for (ActivityManager.RunningAppProcessInfo ai : lstAppInfo) {
         if (ai.pid == givenPid) {
            return ai.processName;
         }
      }
      // added to take care of calling services as well:
      List<ActivityManager.RunningServiceInfo> srvInfo = am
            .getRunningServices(Integer.MAX_VALUE);
      for (ActivityManager.RunningServiceInfo si : srvInfo) {
         if (si.pid == givenPid) {
            return si.process;
         }
      }
      return null;
   }

}
